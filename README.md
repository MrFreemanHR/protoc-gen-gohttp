protoc-gen-gohttp
=================

[![CircleCI](https://circleci.com/gh/nametake/protoc-gen-gohttp.svg?style=svg)](https://circleci.com/gh/nametake/protoc-gen-gohttp)

protoc-gen-gohttp is a plugin for converting Server's interface generated by protoc-gen-go's gRPC plugin to http.Handler.

In addition to this plugin, you need the protoc command and the proto-gen-go plugin.

The converted http.Handler checks Content-Type Header, and changes Marshal/Unmarshal packages. The correspondence table is as follows.

| Content-Type           | package                           |
|------------------------|-----------------------------------|
| application/json       | github.com/golang/protobuf/jsonpb |
| application/protobuf   | github.com/golang/protobuf/proto  |
| application/x-protobuf | github.com/golang/protobuf/proto  |

Install
-------

```console
go get -u github.com/nametake/protoc-gen-gohttp
```

And install dependent tools. (e.g. macOS)

```console
brew install protobuf
go get -u github.com/golang/protobuf/protoc-gen-go
```

How to use
----------

```console
protoc --go_out=plugins=grpc:. --gohttp_out=. *.proto
```

Example
-------

### Run

You can execute examples with the following command.

```console
make run_examples
```

You can confirm the operation with the following command.

```console
curl -H "Content-Type: application/json" localhost:8080/sayhello -d '{"name": "john"}'
curl -H "Content-Type: application/json" localhost:8080/greeter/sayhello -d '{"name": "john"}'
```

### Description

Define greeter.proto.

```proto
syntax = "proto3";

package helloworld;

option go_package = "main";

service Greeter {
  rpc SayHello(HelloRequest) returns (HelloReply) {}
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
```

From greeter.proto you defined, use the following command to generate greeter.pb.go and greeter.http.go.

```console
protoc --go_out=plugins=grpc:. --gohttp_out=. examples/greeter.proto
```

Using the generated Go file, implement as follows.

```go
// EchoGreeterServer has implemented the GreeterServer interface that created from the service in proto file.
type EchoGreeterServer struct {
}

// SayHello implements the GreeterServer interface method.
// SayHello returns a greeting to the name sent.
func (s *EchoGreeterServer) SayHello(ctx context.Context, req *HelloRequest) (*HelloReply, error) {
	return &HelloReply{
		Message: fmt.Sprintf("Hello, %s!", req.Name),
	}, nil
}

func main() {
	// Create the GreeterServer.
	srv := &EchoGreeterServer{}

	// Create the GreeterHTTPConverter generated by protoc-gen-gohttp.
	// This converter converts the GreeterServer interface that created from the service in proto to http.HandlerFunc.
	conv := NewGreeterHTTPConverter(srv)

	// Register SayHello HandlerFunc to the server.
	// If you do not need a callback, pass nil as argument.
	http.Handle("/sayhello", conv.SayHello(logCallback))
	// If you need an auto-generated Path, use the SayHelloWithPath method.
	// In this case, the string '/greeter/sayhello' is returned.
	http.Handle(conv.SayHelloWithPath(logCallback))

	http.ListenAndServe(":8080", nil)
}

// logCallback is called when exiting ServeHTTP
// and receives Context, ResponseWriter, Request, service argument, service return value and error.
func logCallback(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error) {
	log.Printf("INFO: call %s: arg: {%v}, ret: {%s}", r.RequestURI, arg, ret)
	if err != nil {
		log.Printf("ERROR: %v", err)
	}
}
```

NOT SUPOPRTED
-------------

-	Streaming API
	-	Not create a convert method.
-	Protocol Buffers Options
